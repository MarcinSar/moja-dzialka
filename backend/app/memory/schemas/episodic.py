"""
Episodic Memory - Compressed History.

Stores compressed summaries of past sessions, not full transcripts.
This prevents context rot while maintaining continuity.
"""

from pydantic import BaseModel, Field
from typing import List, Dict, Optional, Any
from datetime import date, datetime


class SearchSession(BaseModel):
    """Compressed record of one search session.

    Instead of storing full conversation history, we store:
    - What was searched for
    - What was shown
    - How user reacted
    """
    session_id: str
    date: date

    # Summary (2-3 sentences, generated by LLM)
    summary: str

    # Search criteria used
    search_criteria: Dict[str, Any] = Field(default_factory=dict)

    # Results and reactions
    parcels_shown: List[str] = Field(default_factory=list)  # parcel IDs
    user_reactions: Dict[str, str] = Field(default_factory=dict)  # {"parcel_id": "liked/rejected/interested"}

    # Outcomes
    favorites: List[str] = Field(default_factory=list)
    feedback_summary: Optional[str] = None  # "User prefers quieter locations"

    # Phase reached
    max_phase_reached: str = "DISCOVERY"

    # Duration
    duration_minutes: Optional[int] = None
    message_count: int = 0


class SearchPattern(BaseModel):
    """Recurring search pattern for recommendations.

    Built up from multiple search sessions to identify preferences.
    """
    # Location pattern
    location_preference: Optional[str] = None  # "west_gdansk", "near_forest"
    preferred_districts: List[str] = Field(default_factory=list)

    # Budget pattern
    budget_range: Optional[tuple] = None  # (min, max)

    # Size pattern
    size_preference: Optional[str] = None  # "pod_dom", "duza"
    area_range: Optional[tuple] = None  # (min_m2, max_m2)

    # Feature importance (learned from reactions)
    feature_importance: Dict[str, float] = Field(default_factory=dict)
    # e.g., {"quietness": 0.8, "nature": 0.7, "accessibility": 0.3}

    # Pattern strength
    count: int = 1  # How many times this pattern appeared
    last_seen: Optional[date] = None
    confidence: float = 0.5  # 0-1, how reliable this pattern is


class EpisodicMemory(BaseModel):
    """Compressed session history.

    Maintains last N sessions and extracted patterns.
    This is the "what happened before" memory.
    """
    # Recent sessions (sliding window)
    search_sessions: List[SearchSession] = Field(default_factory=list)
    max_sessions: int = 20  # Keep last 20 sessions

    # Learned patterns (aggregated from sessions)
    search_patterns: List[SearchPattern] = Field(default_factory=list)

    # All-time stats
    all_time_favorites: List[str] = Field(default_factory=list)  # parcel IDs
    all_time_rejections: List[str] = Field(default_factory=list)

    # Conversation highlights (important moments)
    key_moments: List[str] = Field(default_factory=list)
    # e.g., ["User mentioned budget 700k", "User has school-age children"]

    def add_session(self, session: SearchSession) -> None:
        """Add session and maintain sliding window."""
        self.search_sessions.append(session)
        if len(self.search_sessions) > self.max_sessions:
            self.search_sessions = self.search_sessions[-self.max_sessions:]

        # Update patterns based on new session
        self._update_patterns(session)

    def add_favorite(self, parcel_id: str) -> None:
        """Add parcel to all-time favorites (deduplicated)."""
        if parcel_id not in self.all_time_favorites:
            self.all_time_favorites.append(parcel_id)
        # Remove from rejections if present
        if parcel_id in self.all_time_rejections:
            self.all_time_rejections.remove(parcel_id)

    def add_rejection(self, parcel_id: str) -> None:
        """Add parcel to all-time rejections (deduplicated)."""
        if parcel_id not in self.all_time_rejections:
            self.all_time_rejections.append(parcel_id)
        # Remove from favorites if present
        if parcel_id in self.all_time_favorites:
            self.all_time_favorites.remove(parcel_id)

    def add_key_moment(self, moment: str) -> None:
        """Add a key moment to remember."""
        if moment not in self.key_moments:
            self.key_moments.append(moment)
            # Keep last 50 key moments
            if len(self.key_moments) > 50:
                self.key_moments = self.key_moments[-50:]

    def get_recent_summary(self, n: int = 3) -> str:
        """Get summary of last N sessions."""
        if not self.search_sessions:
            return "Brak poprzednich sesji."

        recent = self.search_sessions[-n:]
        summaries = [f"- {s.date}: {s.summary}" for s in recent]
        return "\n".join(summaries)

    def _update_patterns(self, session: SearchSession) -> None:
        """Update search patterns based on new session."""
        # Extract criteria from session
        criteria = session.search_criteria
        if not criteria:
            return

        # Find or create matching pattern
        pattern = self._find_matching_pattern(criteria)
        if pattern is None:
            pattern = SearchPattern(
                last_seen=session.date,
                count=1,
            )
            self.search_patterns.append(pattern)
        else:
            pattern.count += 1
            pattern.last_seen = session.date
            pattern.confidence = min(0.9, pattern.confidence + 0.1)

        # Update pattern details
        if criteria.get("gmina"):
            if criteria["gmina"] not in pattern.preferred_districts:
                pattern.preferred_districts.append(criteria["gmina"])

        if criteria.get("min_area_m2") and criteria.get("max_area_m2"):
            pattern.area_range = (criteria["min_area_m2"], criteria["max_area_m2"])

        # Learn from reactions
        for parcel_id, reaction in session.user_reactions.items():
            if reaction == "liked":
                pattern.feature_importance["quietness"] = pattern.feature_importance.get("quietness", 0.5) + 0.05
            elif reaction == "rejected":
                pattern.feature_importance["quietness"] = pattern.feature_importance.get("quietness", 0.5) - 0.05

    def _find_matching_pattern(self, criteria: dict) -> Optional[SearchPattern]:
        """Find existing pattern that matches criteria."""
        # Simple matching by location
        gmina = criteria.get("gmina")
        for pattern in self.search_patterns:
            if gmina and gmina in pattern.preferred_districts:
                return pattern
        return None
